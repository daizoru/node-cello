// Generated by CoffeeScript 1.4.0
(function() {
  var C, CParser, P, TYPES, copy, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, pro, resolve, spawn, tmp, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  inspect = require('util').inspect;

  spawn = require('child_process').spawn;

  tmp = require('tmp');

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  TYPES = ['int', 'uint', 'float', 'ufloat', 'long', 'ulong', 'double', '_const', 'char', 'uchar', 'float16', 'float32', 'int16', 'int32', 'FILE', 'typedef', 'signed', 'wchar_t', 'wchar', 'size_t', 'struct', '__kernel', 'void', 'Void', 'VOID', 'bool', 'boolean', 'integer', 'const'];

  resolve = function(item) {
    var name, sub;
    name = "";
    if (item[0] === 'dot') {
      sub = "";
      if (isArray(item[1])) {
        sub = "" + resolve(item[1]);
      } else {
        sub = item[1][1];
      }
      name = "" + sub + "." + item[2];
    } else if (item[0] === 'name') {
      name = item[1];
    }
    return name;
  };

  CParser = function(func, options) {
    var ast, debug, ev, evaluate, headers, ig, ignore, include, includes, indent, indentationStr, node, output, parse, pretty, scope, scopes, _i, _len, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    debug = (_ref = options.debug) != null ? _ref : false;
    indentationStr = (_ref1 = options.indent) != null ? _ref1 : '\t';
    debug = debug ? console.log : function() {};
    indent = function(n) {
      var _i;
      if (n == null) {
        n = 0;
      }
      tmp = "";
      if (indentationStr) {
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          tmp += indentationStr;
        }
      }
      return tmp;
    };
    evaluate = [];
    if (options.evaluate != null) {
      ev = toAST("var EVALUATED = " + (options.evaluate.toString()) + ";");
      ev = ev[1][0][1][0][1][3][0][1][1];
      evaluate = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ev.length; _i < _len; _i++) {
          node = ev[_i];
          _results.push(resolve(node));
        }
        return _results;
      })();
    }
    debug("evaluated references: " + (inspect(evaluate, false, 20, true)));
    ignore = [];
    if (options.ignore != null) {
      ig = toAST("var IGNORED = " + (options.ignore.toString()) + ";");
      ig = ig[1][0][1][0][1][3][0][1][1];
      ignore = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ig.length; _i < _len; _i++) {
          node = ig[_i];
          _results.push(resolve(node));
        }
        return _results;
      })();
    }
    debug("ignored references: " + (inspect(ignore, false, 20, true)));
    ignore = ['mutable', 'mutateNow', '_results'];
    ast = toAST("var ROOT = " + (func.toString()) + ";");
    debug("AST: " + (inspect(ast, false, 20, true)));
    includes = [];
    scopes = [{}];
    scope = 0;
    pretty = function(n) {
      return "" + (inspect(n, false, 20, true));
    };
    output = (parse = function(nodes, ind) {
      var arg, args, buff, callee, code, cut, elements, first, n, name, nbArgs, p, param1, params, replaceOperators, statements, str, type, _i, _j, _len, _len1, _ref2;
      if (!isArray(nodes)) {
        return "";
      }
      type = nodes[0];
      first = nodes[1];
      if (ind == null) {
        ind = 0;
      }
      switch (type) {
        case 'num':
          return "" + first;
        case 'dot':
          name = resolve(nodes);
          if (__indexOf.call(evaluate, name) >= 0) {
            return "" + (eval(name));
          } else if (__indexOf.call(ignore, name) >= 0) {
            return "";
          } else {
            return "" + (isArray(first) ? parse(first) : first[1]) + "." + nodes[2];
          }
          break;
        case 'name':
          name = resolve(nodes);
          if (__indexOf.call(evaluate, name) >= 0) {
            return "" + (eval(name));
          } else if (__indexOf.call(ignore, name) >= 0) {
            return "";
          } else {
            if (first === '_void' || first === 'VOID' || first === 'Void') {
              return "void";
            } else {
              return first.replace('$', '*');
            }
          }
          break;
        case 'string':
          debug("STRING");
          str = first;
          str.replace("\n", "\\n");
          return "\"" + str + "\"";
        case 'unary-postfix':
          debug("unary postfix");
          debug(pretty(nodes));
          return "" + (parse(nodes[2])) + nodes[1];
        case 'unary-prefix':
          debug("unary prefix");
          debug(pretty(nodes));
          return "" + nodes[1] + (parse(nodes[2]));
        case 'block':
          debug('block');
          debug(pretty(nodes));
          return "{\n" + (parse(nodes[1], ind + 1)) + (indent(ind)) + "}\n";
        case 'if':
          debug("if");
          debug(pretty(nodes));
          return "" + (indent(ind)) + "if (" + (parse(nodes[1])) + ") " + (parse(nodes[2], ind));
        case 'while':
          debug("WHILE LOOP");
          debug(pretty(nodes));
          return "" + (indent(ind)) + "while (" + (parse(nodes[1])) + ") " + (parse(nodes[2], ind));
        case 'binary':
          debug("BINARY OPERATION");
          replaceOperators = {
            '===': '==',
            '!==': '!='
          };
          first = first in replaceOperators ? replaceOperators[first] : first;
          return parse(nodes[2]) + (" " + first + " ") + parse(nodes[3]);
        case 'sub':
          debug("ARRAY INDEX");
          return "" + (parse(first)) + "[" + (parse(nodes[2])) + "]";
        case 'array':
          debug("ARRAY");
          debug(pretty(first));
          elements = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = first.length; _i < _len; _i++) {
              n = first[_i];
              _results.push(parse(n));
            }
            return _results;
          })();
          return "{" + (elements.join(', ')) + "}";
        case 'return':
          debug("RETURN");
          if (first[0] === 'call' && (_ref2 = first[1][1], __indexOf.call(TYPES, _ref2) >= 0)) {
            return parse(first);
          } else {
            return "" + (indent(ind)) + "return " + (parse(first)) + ";\n";
          }
          break;
        case 'assign':
          debug("ASSIGN");
          if (nodes[3][0] === 'function') {
            debug("FUNCTION ASSIGNEMENT");
            statements = (function() {
              var _i, _len, _ref3, _results;
              _ref3 = nodes[3][3];
              _results = [];
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                n = _ref3[_i];
                _results.push(parse(n, ind + 1));
              }
              return _results;
            })();
            debug("LOOKING FOR  DEFINITION: " + (pretty(nodes[3])));
            nbArgs = nodes[3][2].length;
            args = [];
            if (nbArgs > 0) {
              console.log("nbArgs: " + nbArgs);
              args = statements.slice(1, +nbArgs + 1 || 9e9);
              args = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = args.length; _i < _len; _i++) {
                  arg = args[_i];
                  _results.push(arg.trim().replace(';', '').replace('\n', ''));
                }
                return _results;
              })();
              statements = statements.slice(nbArgs + 1);
            }
            return parse(nodes[2]) + ("(" + (args.join(',')) + ") {\n") + statements.join('') + "}\n";
          } else {
            debug("CLASSIC ASSIGN");
            return parse(nodes[2]) + " = " + parse(nodes[3]);
          }
          break;
        case 'stat':
          debug("STATEMENT");
          debug(pretty(nodes));
          if (resolve(nodes[1][1]) === 'include') {
            return "" + (indent(ind)) + "#include <" + nodes[1][2][0][1] + ">\n";
          } else {
            return indent(ind) + parse(first, ind + 1) + ";\n";
          }
          break;
        case 'call':
          debug("CALL");
          debug(pretty(nodes));
          callee = resolve(nodes[1]);
          params = nodes[2];
          debug("CALLEE: " + callee);
          if (__indexOf.call(ignore, callee) >= 0) {
            cut = params[0][3];
            buff = "";
            for (_i = 0, _len = cut.length; _i < _len; _i++) {
              node = cut[_i];
              buff += parse(node, ind);
            }
            return buff;
          } else if (__indexOf.call(evaluate, callee) >= 0) {
            code = pro.gen_code(nodes, {});
            return "" + (eval(code));
          } else {
            param1 = params[0];
            debug("PARAM 1:");
            debug(pretty(param1));
            if (__indexOf.call(TYPES, callee) >= 0) {
              debug("typed assignement");
              return "" + callee + " " + (parse(param1));
            } else {
              if (param1[0] === 'call' && param1[2][0][0] === 'assign') {
                return debug("two-level typing declaration");
              } else {
                params = (function() {
                  var _j, _len1, _results;
                  _results = [];
                  for (_j = 0, _len1 = params.length; _j < _len1; _j++) {
                    p = params[_j];
                    _results.push(parse(p, ind));
                  }
                  return _results;
                })();
                return "" + callee + "(" + (params.join(',')) + ")";
              }
            }
          }
          /*
                      buff = callee # type 1
                      buff += resolve param1 # type 2
                      if param1[2][0][3][0] is 'function'
                        debug "of a function, great"
                        buff += " #{resolve param1[2][0][2]}" # func name
                        buff += " ()"
                        buff += " {\n"
                        body = ""
                        statements = param1[2][0][3][3]
                        #debug "body: #{inspect statements, no, 20, yes}"
                        for statement in statements
                          body += parse statement, ind + 1
                        buff += body
                        buff += "\n}\n"
                      else
                        debug "of a variable"
                        buff += "#{nodeToString param1[2][0][4]}"
                      res += buff
                    else if param1[0] is 'assign'
                      debug "simple level typing: #{inspect parameters, no, 20, yes}"
                      buff = "#{resolve nodes[1]}" # type
                      res += buff
                      
                    else # just a call
                      debug "NOT a function"
                      res += functionCall nodes[1], parameters, ind
          */

          break;
        case 'assign':
          debug("ASSIGNEMENT");
          return debug(pretty(nodes));
          /*
                  if nodes[2][0] is 'sub'
                    assigned = nodeToString nodes[2]
                    value = parse nodes[3]
                    "#{assigned} = #{value}"
                  else if nodes[2][1] is 'main'
                    args = nodes[3][2]
                    statements = nodes[3][3]
                    mainCall args, statements, ind
                  else
                    assigned = nodeToString nodes[2]
                    value = parse nodes[3]
                    "#{assigned} = #{value}"
          */

        default:
          buff = "";
          for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
            node = nodes[_j];
            buff += parse(node, ind);
          }
          return buff;
      }
    })(ast, 0);
    headers = "";
    for (_i = 0, _len = includes.length; _i < _len; _i++) {
      include = includes[_i];
      headers += "#include <" + include + ">\n";
    }
    output = headers + output + "\n";
    return output;
  };

  exports.compile = function(src, onComplete) {
    if (onComplete == null) {
      onComplete = function() {};
    }
    return fs.writeFile('output.c', src, function(err) {
      var gcc;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', ['output.c', '-o-']);
      gcc.on('exit', function(code, signal) {
        return onComplete(gcc.stdout);
      });
      return gcc.stdin.end();
    });
  };

  exports.run = function(src, onComplete) {
    var binFile, srcFile;
    if (onComplete == null) {
      onComplete = function() {};
    }
    srcFile = 'output.c';
    binFile = 'output';
    return fs.writeFile(srcFile, src, function(err) {
      var gcc, _gccstderr;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', [srcFile, '-o', binFile]);
      _gccstderr = "";
      gcc.stderr.on('data', function(data) {
        return _gccstderr += data.toString();
      });
      gcc.on('exit', function(code, signal) {
        var prog, _stderr, _stdout;
        if (code !== 0) {
          onComplete(_gccstderr, "");
          return;
        }
        prog = spawn("./" + binFile, []);
        prog.stdin.end();
        _stdout = "";
        prog.stdout.on('data', function(data) {
          return _stdout += data.toString();
        });
        _stderr = "";
        prog.stderr.on('data', function(data) {
          return _stderr += data.toString();
        });
        return prog.on('exit', function(code, signal) {
          fs.unlink(binFile, function() {
            return fs.unlink(srcFile, function() {});
          });
          return onComplete(void 0, _stdout);
        });
      });
      return gcc.stdin.end();
    });
  };

  /*
  TODO
  
  we cannot use the coffee-script parse, because we need to parse at runtime,
  when the code is already JS
  
  so we need to strip out variables auto-generated by coffee, basically
  _results
  */


  exports.C = C = function(input) {
    var options;
    options = {};
    if (isFunction(input)) {
      return CParser(input, options);
    } else {
      options = input;
      return function(input) {
        return CParser(input, options);
      };
    }
  };

}).call(this);
