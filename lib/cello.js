// Generated by CoffeeScript 1.4.0
(function() {
  var C, CParser, P, copy, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, pro, resolve, spawn, tmp, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  inspect = require('util').inspect;

  spawn = require('child_process').spawn;

  tmp = require('tmp');

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  resolve = function(item) {
    var name, sub;
    name = "";
    if (item[0] === 'dot') {
      sub = "";
      if (isArray(item[1])) {
        sub = "" + resolve(item[1]);
      } else {
        sub = item[1][1];
      }
      name = "" + sub + "." + item[2];
    } else if (item[0] === 'name') {
      name = item[1];
    }
    return name;
  };

  CParser = function(func, options) {
    var ast, debug, evaluate, functionCall, functionDef, headers, ignore, include, includes, indent, indentationStr, mainCall, nodeToString, output, parseStatement, scope, scopes, src, _i, _len, _ref, _ref1, _ref2, _ref3;
    if (options == null) {
      options = {};
    }
    debug = (_ref = options.debug) != null ? _ref : false;
    indentationStr = (_ref1 = options.indent) != null ? _ref1 : '\t';
    debug = debug ? console.log : function() {};
    indent = function(n) {
      var _i;
      if (n == null) {
        n = 0;
      }
      tmp = "";
      if (indentationStr) {
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          tmp += indentationStr;
        }
      }
      return tmp;
    };
    evaluate = (_ref2 = options.evaluate) != null ? _ref2 : function() {};
    evaluate = "var EVALUATED = " + (evaluate.toString()) + ";";
    debug("evaluate: " + evaluate);
    evaluate = ['Math.random', 'Math.round'];
    ignore = (_ref3 = options.ignore) != null ? _ref3 : function() {};
    ignore = "var IGNORED = " + (ignore.toString()) + ";";
    debug("ignore: " + ignore);
    ignore = ['mutable', 'mutateNow', '_results'];
    src = func.toString();
    src = "var ROOT = " + src + ";";
    debug("src: " + src);
    ast = toAST(src);
    debug("AST: " + (inspect(ast, false, 20, true)));
    includes = [];
    scopes = [{}];
    scope = 0;
    nodeToString = function(n, ind) {
      var code, element, elements, p, params, str, _ref4, _ref5;
      if (ind == null) {
        ind = 0;
      }
      debug("VALUE " + (inspect(n, false, 20, true)));
      if (n[0] === 'binary') {
        return "" + (nodeToString(n[2])) + " " + n[1] + " " + (nodeToString(n[3]));
      } else if (n[0] === 'sub') {
        debug("SUB: " + n);
        return "" + n[1][1] + "[" + n[2][1] + "]";
      } else if (n[0] === 'array') {
        elements = (function() {
          var _i, _len, _ref4, _results;
          _ref4 = n[1];
          _results = [];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            element = _ref4[_i];
            _results.push(nodeToString(element));
          }
          return _results;
        })();
        return "{" + (elements.join(', ')) + "}";
      } else if (_ref4 = n[0], __indexOf.call(ignore, _ref4) >= 0) {
        return nodeToString(n[1]);
      } else if (_ref5 = resolve(n[1]), __indexOf.call(evaluate, _ref5) >= 0) {
        code = pro.gen_code(n, {});
        return eval(code);
      } else if (n[0] === 'call') {
        params = (function() {
          var _i, _len, _ref6, _results;
          _ref6 = n[2];
          _results = [];
          for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
            p = _ref6[_i];
            _results.push(nodeToString(p));
          }
          return _results;
        })();
        return "" + n[1][1] + "(" + (params.join(', ')) + ")";
      } else if (n[0] === 'string') {
        str = n[1];
        str.replace("\n", "\\n");
        return "\"" + str + "\"";
      } else if (isString(n[1])) {
        return "" + (n[1].replace('$', '*'));
      } else {
        return "" + n[1];
      }
    };
    functionDef = function(args, statements, ind) {
      var arg, body, res, statement, tmp2;
      if (ind == null) {
        ind = 0;
      }
      res = "";
      debug("FUNCTION " + args + "  " + statements);
      tmp = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          _results.push(nodeToString(arg));
        }
        return _results;
      })();
      args = tmp;
      body = "";
      tmp2 = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = statements.length; _i < _len; _i++) {
          statement = statements[_i];
          _results.push(body += parseStatement(statement, ind + 1));
        }
        return _results;
      })();
      return "int name(" + args + ") {\n" + body + (indent(ind + 1)) + "return 0;\n}\n";
    };
    mainCall = function(args, statements, ind) {
      var arg, body, res, statement, tmp2;
      if (ind == null) {
        ind = 0;
      }
      res = "";
      debug("MAIN " + args + "  " + statements);
      tmp = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          _results.push(nodeToString(arg));
        }
        return _results;
      })();
      args = tmp;
      body = "";
      tmp2 = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = statements.length; _i < _len; _i++) {
          statement = statements[_i];
          _results.push(body += parseStatement(statement, ind + 1));
        }
        return _results;
      })();
      return "int main(" + args + ") {\n" + body + (indent(ind + 1)) + "return 0;\n}\n";
    };
    functionCall = function(func, args, ind) {
      var arg, assignedValue, assignedVarName, res, symbol, _ref4;
      if (ind == null) {
        ind = 0;
      }
      res = "";
      debug("FUNCTION " + func[1] + " with args: " + (inspect(args, false, 20, true)));
      symbol = func[1];
      if (_ref4 = func[1][1], __indexOf.call(ignore, _ref4) >= 0) {
        debug("bad function call, ignoring");
        res += parseStatement(args);
      } else if (symbol === 'int' || symbol === 'uint' || symbol === 'float' || symbol === 'ufloat' || symbol === 'double' || symbol === 'char' || symbol === 'bool' || symbol === 'boolean' || symbol === '_void') {
        if (args[0][0] === 'assign') {
          debug("ASSIGN: " + (inspect(args, false, 20, true)));
          assignedVarName = nodeToString(args[0][2]);
          assignedValue = nodeToString(args[0][3]);
          res += "" + (indent(ind)) + symbol + " " + assignedVarName + " = " + assignedValue + ";\n";
        }
      } else if (symbol === 'include') {
        res += "" + (indent(ind)) + "#include <" + args[0][1] + ">\n";
      } else if (__indexOf.call(ignore, symbol) >= 0) {
        debug("function symbol " + symbol + " is in ignore list " + ignore);
        res += nodeToString(args[0], ind);
      } else {
        tmp = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            _results.push(nodeToString(arg));
          }
          return _results;
        })();
        args = tmp;
        res += "" + (indent(ind)) + func[1] + "(" + args + ");\n";
      }
      return res;
    };
    output = (parseStatement = function(nodes, ind) {
      var args, assigned, body, cond, n, node, res, statement, statements, value, _i, _j, _k, _len, _len1, _len2, _ref4, _ref5, _ref6;
      res = "";
      n = "" + nodes;
      if (isArray(nodes) && nodes[0] === 'unary-postfix') {
        debug("unary postfix: " + (inspect(nodes, false, 20, true)));
        res += "" + (indent(ind)) + nodes[2][1] + nodes[1] + ";";
      } else if (isArray(nodes) && nodes[0] === 'unary-prefix') {
        debug("unary prefix: " + (inspect(nodes, false, 20, true)));
        res += "" + (indent(ind)) + nodes[1] + nodes[2][1] + ";";
      } else if (isArray(nodes) && nodes[0] === 'while') {
        debug("WHILE: " + (inspect(nodes[2], false, 20, true)));
        cond = nodeToString(nodes[1], ind);
        body = "";
        _ref4 = nodes[2][1];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          statement = _ref4[_i];
          body += parseStatement(statement, ind + 1);
        }
        res += "" + (indent(ind)) + "while (" + cond + ") {\n" + body + "\n" + (indent(ind)) + "}\n";
      } else if (isArray(nodes) && nodes[0] === 'call') {
        debug("checking if " + nodes[1][1] + " is in " + ignore);
        if (_ref5 = nodes[1][1], __indexOf.call(ignore, _ref5) >= 0) {
          debug("IGNORE func: " + nodes[1] + ", args: " + (inspect(nodes[2], false, 20, true)));
          _ref6 = nodes[2][0][3];
          for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
            statement = _ref6[_j];
            res += parseStatement(statement, ind);
          }
        } else {
          debug("NOT ignoring");
          res += functionCall(nodes[1], nodes[2], ind);
        }
      } else if (isArray(nodes) && nodes[0] === 'assign') {
        debug("ASSIGNEMENT NOT USED????");
        if (nodes[2][0] === 'sub') {
          assigned = nodeToString(nodes[2]);
          value = parseStatement(nodes[3]);
          res += "" + assigned + " = " + value;
        } else if (nodes[2][1] === 'main') {
          args = nodes[3][2];
          statements = nodes[3][3];
          res += mainCall(args, statements, ind);
        } else {
          assigned = nodeToString(nodes[2]);
          value = parseStatement(nodes[3]);
          res += "" + assigned + " = " + value;
        }
      } else if (isArray(nodes)) {
        for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
          node = nodes[_k];
          res += parseStatement(node, ind);
        }
      }
      return res;
    })(ast, 0);
    headers = "";
    for (_i = 0, _len = includes.length; _i < _len; _i++) {
      include = includes[_i];
      headers += "#include <" + include + ">\n";
    }
    output = headers + output + "\n";
    return output;
  };

  exports.compile = function(src, onComplete) {
    if (onComplete == null) {
      onComplete = function() {};
    }
    return fs.writeFile('output.c', src, function(err) {
      var gcc;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', ['output.c', '-o-']);
      gcc.on('exit', function(code, signal) {
        return onComplete(gcc.stdout);
      });
      return gcc.stdin.end();
    });
  };

  exports.run = function(src, onComplete) {
    var binFile, srcFile;
    if (onComplete == null) {
      onComplete = function() {};
    }
    srcFile = 'output.c';
    binFile = 'output';
    return fs.writeFile(srcFile, src, function(err) {
      var gcc, _gccstderr;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', [srcFile, '-o', binFile]);
      _gccstderr = "";
      gcc.stderr.on('data', function(data) {
        return _gccstderr += data.toString();
      });
      gcc.on('exit', function(code, signal) {
        var prog, _stderr, _stdout;
        if (code !== 0) {
          onComplete(_gccstderr, "");
          return;
        }
        prog = spawn("./" + binFile, []);
        prog.stdin.end();
        _stdout = "";
        prog.stdout.on('data', function(data) {
          return _stdout += data.toString();
        });
        _stderr = "";
        prog.stderr.on('data', function(data) {
          return _stderr += data.toString();
        });
        return prog.on('exit', function(code, signal) {
          fs.unlink(binFile, function() {
            return fs.unlink(srcFile, function() {});
          });
          return onComplete(void 0, _stdout);
        });
      });
      return gcc.stdin.end();
    });
  };

  /*
  TODO
  
  we cannot use the coffee-script parse, because we need to parse at runtime,
  when the code is already JS
  
  so we need to strip out variables auto-generated by coffee, basically
  _results
  */


  exports.C = C = function(input) {
    var options;
    options = {};
    if (isFunction(input)) {
      return CParser(input, options);
    } else {
      options = input;
      return function(input) {
        return CParser(input, options);
      };
    }
  };

}).call(this);
