// Generated by CoffeeScript 1.4.0
(function() {
  var C, CParser, P, Program, Stream, TYPES, copy, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, pretty, pro, resolve, spawn, tmp, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require('fs');

  inspect = require('util').inspect;

  spawn = require('child_process').spawn;

  Stream = require('stream');

  tmp = require('tmp');

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  pretty = function(n) {
    return "" + (inspect(n, false, 20, true));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  TYPES = ['int', 'uint', 'float', 'ufloat', 'long', 'ulong', 'double', '_const', 'char', 'uchar', 'float16', 'float32', 'int16', 'int32', 'FILE', 'typedef', 'signed', 'wchar_t', 'wchar', 'size_t', 'struct', '__kernel', 'void', 'Void', 'VOID', 'bool', 'boolean', 'integer', 'const'];

  resolve = function(item) {
    var name, sub;
    name = "";
    if (item[0] === 'dot') {
      sub = "";
      if (isArray(item[1])) {
        sub = "" + resolve(item[1]);
      } else {
        sub = item[1][1];
      }
      name = "" + sub + "." + item[2];
    } else if (item[0] === 'name') {
      name = item[1];
    }
    return name;
  };

  CParser = function(func, options) {
    var arr, ast, debug, ev, evaluate, headers, i, ig, ignore, include, includes, indent, indentationStr, node, output, parse, scope, scopes, _i, _j, _len, _len1, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    debug = (_ref = options.debug) != null ? _ref : false;
    indentationStr = (_ref1 = options.indent) != null ? _ref1 : '\t';
    debug = debug ? console.log : function() {};
    indent = function(n) {
      var _i;
      if (n == null) {
        n = 0;
      }
      tmp = "";
      if (indentationStr) {
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          tmp += indentationStr;
        }
      }
      return tmp;
    };
    evaluate = [];
    if (options.evaluate != null) {
      ev = toAST("var EVALUATED = " + (options.evaluate.toString()) + ";");
      debug(pretty(ev));
      ev = ev[1][0][1][0][1][3][0][1][1];
      i = 0;
      arr = options.evaluate();
      evaluate = {};
      for (_i = 0, _len = ev.length; _i < _len; _i++) {
        node = ev[_i];
        evaluate[resolve(node)] = arr[i++];
      }
    }
    debug("evaluated references: " + pretty(evaluate));
    ignore = [];
    if (options.ignore != null) {
      ig = toAST("var IGNORED = " + (options.ignore.toString()) + ";");
      ig = ig[1][0][1][0][1][3][0][1][1];
      ignore = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = ig.length; _j < _len1; _j++) {
          node = ig[_j];
          _results.push(resolve(node));
        }
        return _results;
      })();
    }
    debug("ignored references: " + pretty(ignore));
    ignore = ['mutable', 'mutateNow', '_results'];
    ast = toAST("var ROOT = " + (func.toString()) + ";");
    debug("AST: " + pretty(ast));
    includes = [];
    scopes = [{}];
    scope = 0;
    output = (parse = function(nodes, ind, parent) {
      var TMP, arg, args, buff, callee, code, cut, elements, fakeAST, first, included, n, name, nbArgs, p, param1, params, replaceOperators, result, stat, statements, str, type, _j, _k, _len1, _len2, _ref2;
      if (!isArray(nodes)) {
        return "";
      }
      type = nodes[0];
      first = nodes[1];
      if (ind == null) {
        ind = 0;
      }
      switch (type) {
        case 'num':
          return "" + first;
        case 'dot':
          name = resolve(nodes);
          if (name in evaluate) {
            return "" + (eval(name));
          } else if (__indexOf.call(ignore, name) >= 0) {
            return "";
          } else {
            return "" + (isArray(first) ? parse(first) : first[1]) + "." + nodes[2];
          }
          break;
        case 'name':
          name = resolve(nodes);
          if (name in evaluate) {
            return "" + (eval(name));
          } else if (__indexOf.call(ignore, name) >= 0) {
            return "";
          } else {
            if (first === '_void' || first === 'VOID' || first === 'Void') {
              return "void";
            } else {
              return first.replace('$', '*');
            }
          }
          break;
        case 'string':
          debug("STRING");
          str = first;
          str.replace("\n", "\\n");
          return "\"" + str + "\"";
        case 'unary-postfix':
          debug("unary postfix");
          return "" + (parse(nodes[2])) + nodes[1];
        case 'unary-prefix':
          debug("unary prefix");
          return "" + nodes[1] + (parse(nodes[2]));
        case 'block':
          debug('block');
          i = -1;
          statements = (function() {
            var _j, _len1, _ref2, _results;
            _ref2 = nodes[1];
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              n = _ref2[_j];
              i++;
              stat = parse(n, ind + 1);
              _results.push(stat);
            }
            return _results;
          })();
          return "{\n" + (statements.join('')) + (indent(ind)) + "}";
        case 'break':
          debug('break');
          return "" + (indent(ind)) + "break";
        case 'continue':
          debug('continue');
          return "" + (indent(ind)) + "continue";
        case 'if':
          debug("if");
          return "" + (indent(ind)) + "if (" + (parse(nodes[1])) + ") " + (parse(nodes[2], ind));
        case 'while':
          debug("WHILE LOOP");
          return "" + (indent(ind)) + "while (" + (parse(nodes[1])) + ") " + (parse(nodes[2], ind));
        case 'binary':
          debug("BINARY OPERATION");
          replaceOperators = {
            '===': '==',
            '!==': '!='
          };
          first = first in replaceOperators ? replaceOperators[first] : first;
          return parse(nodes[2]) + (" " + first + " ") + parse(nodes[3]);
        case 'sub':
          debug("ARRAY INDEX");
          return "" + (parse(first)) + "[" + (parse(nodes[2])) + "]";
        case 'array':
          debug("ARRAY");
          debug(pretty(first));
          elements = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = first.length; _j < _len1; _j++) {
              n = first[_j];
              _results.push(parse(n));
            }
            return _results;
          })();
          return "{" + (elements.join(', ')) + "}";
        case 'return':
          debug("RETURN");
          if (first[0] === 'call' && (_ref2 = first[1][1], __indexOf.call(TYPES, _ref2) >= 0)) {
            return parse(first);
          } else {
            return ("" + (indent(ind)) + "return " + (parse(first))) + ";\n";
          }
          break;
        case 'assign':
          debug("ASSIGN");
          if (nodes[3][0] === 'function') {
            debug("FUNCTION ASSIGNEMENT");
            debug(nodes);
            i = -1;
            statements = (function() {
              var _j, _len1, _ref3, _results;
              _ref3 = nodes[3][3];
              _results = [];
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                n = _ref3[_j];
                i++;
                stat = parse(n, ind + 1);
                _results.push(stat);
              }
              return _results;
            })();
            debug("LOOKING FOR  DEFINITION: " + (pretty(nodes[3])));
            nbArgs = nodes[3][2].length;
            args = [];
            if (nbArgs > 0) {
              args = statements.slice(1, +nbArgs + 1 || 9e9);
              args = (function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
                  arg = args[_j];
                  _results.push(arg.trim().replace(';', '').replace('\n', ''));
                }
                return _results;
              })();
              statements = statements.slice(nbArgs + 1);
            }
            if ((parent != null) && parent[1][1] === 'struct') {
              if (statements.length) {
                statements[statements.length - 1] = statements[statements.length - 1].replace('return ', '');
              }
              return parse(nodes[2]) + " {\n" + statements.join('') + ("\n" + (indent(ind)) + "};\n");
            } else {
              return parse(nodes[2]) + ("(" + (args.join(',')) + ") {\n") + statements.join('') + "}\n";
            }
          } else {
            debug("CLASSIC ASSIGN");
            return parse(nodes[2]) + " = " + parse(nodes[3]);
          }
          break;
        case 'stat':
          debug("STATEMENT");
          debug(pretty(nodes));
          if (resolve(nodes[1][1]) === 'include') {
            included = nodes[1][2][0][1];
            if (included[0] === '<' && included[included.length - 1] === '>') {
              return "" + (indent(ind)) + "#include " + included + "\n";
            } else {
              return "" + (indent(ind)) + "#include \"" + included + "\"\n";
            }
          } else {
            return indent(ind) + parse(first, ind + 1) + ";\n";
          }
          break;
        case 'call':
          debug("CALL");
          debug(pretty(nodes));
          callee = resolve(nodes[1]);
          params = nodes[2];
          debug("CALLEE: " + callee);
          if (__indexOf.call(ignore, callee) >= 0) {
            cut = params[0][3];
            buff = "";
            for (_j = 0, _len1 = cut.length; _j < _len1; _j++) {
              node = cut[_j];
              buff += parse(node, ind);
            }
            return buff;
          } else if (callee in evaluate) {
            debug("callee: " + callee + " params: " + params);
            debug("function: " + evaluate[callee]);
            TMP = function() {};
            fakeAST = ['toplevel', [['var', [['TMP', ['function', null, [], [['return', params[0]]]]]]]]];
            debug("fakeAST: " + (pretty(fakeAST)));
            code = pro.gen_code(fakeAST, {});
            debug("code: " + code);
            eval(code);
            debug("TMP: " + TMP + "  res: " + (TMP()));
            result = evaluate[callee](TMP());
            if (isString(result)) {
              return "\"" + result + "\"";
            } else {
              return "" + result;
            }
          } else {
            param1 = params[0];
            debug("PARAM 1:");
            debug(pretty(param1));
            if (__indexOf.call(TYPES, callee) >= 0) {
              debug("typed assignement");
              return "" + callee + " " + (parse(param1, 0, nodes));
            } else {
              if (param1[0] === 'call' && param1[2][0][0] === 'assign') {
                return debug("two-level typing declaration");
              } else {
                params = (function() {
                  var _k, _len2, _results;
                  _results = [];
                  for (_k = 0, _len2 = params.length; _k < _len2; _k++) {
                    p = params[_k];
                    _results.push(parse(p, ind));
                  }
                  return _results;
                })();
                return "" + callee + "(" + (params.join(',')) + ")";
              }
            }
          }
          /*
                      buff = callee # type 1
                      buff += resolve param1 # type 2
                      if param1[2][0][3][0] is 'function'
                        debug "of a function, great"
                        buff += " #{resolve param1[2][0][2]}" # func name
                        buff += " ()"
                        buff += " {\n"
                        body = ""
                        statements = param1[2][0][3][3]
                        #debug "body: #{inspect statements, no, 20, yes}"
                        for statement in statements
                          body += parse statement, ind + 1
                        buff += body
                        buff += "\n}\n"
                      else
                        debug "of a variable"
                        buff += "#{nodeToString param1[2][0][4]}"
                      res += buff
                    else if param1[0] is 'assign'
                      debug "simple level typing: #{inspect parameters, no, 20, yes}"
                      buff = "#{resolve nodes[1]}" # type
                      res += buff
                      
                    else # just a call
                      debug "NOT a function"
                      res += functionCall nodes[1], parameters, ind
          */

          break;
        case 'assign':
          debug("ASSIGNEMENT");
          return debug(pretty(nodes));
          /*
                  if nodes[2][0] is 'sub'
                    assigned = nodeToString nodes[2]
                    value = parse nodes[3]
                    "#{assigned} = #{value}"
                  else if nodes[2][1] is 'main'
                    args = nodes[3][2]
                    statements = nodes[3][3]
                    mainCall args, statements, ind
                  else
                    assigned = nodeToString nodes[2]
                    value = parse nodes[3]
                    "#{assigned} = #{value}"
          */

        default:
          buff = "";
          for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
            node = nodes[_k];
            buff += parse(node, ind);
          }
          return buff;
      }
    })(ast, 0, void 0);
    headers = "";
    for (_j = 0, _len1 = includes.length; _j < _len1; _j++) {
      include = includes[_j];
      headers += "#include <" + include + ">\n";
    }
    output = headers + output + "\n";
    return output;
  };

  exports.compile = function(src, onComplete) {
    if (onComplete == null) {
      onComplete = function() {};
    }
    return fs.writeFile('output.c', src, function(err) {
      var gcc;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', ['output.c', '-o-']);
      gcc.on('exit', function(code, signal) {
        return onComplete(gcc.stdout);
      });
      return gcc.stdin.end();
    });
  };

  exports.run = function(src, a, b) {
    var args, binFile, onComplete, srcFile;
    onComplete = function() {};
    args = [];
    if (b != null) {
      onComplete = b;
      args = a;
    } else {
      if (a != null) {
        if (isFunction(a)) {
          onComplete = a;
        } else {
          throw new Error("onComplete (second argument here) must be a function");
        }
      } else {
        0;

      }
    }
    srcFile = 'output.c';
    binFile = 'output';
    return fs.writeFile(srcFile, src, function(err) {
      var gcc, _gccstderr;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', [srcFile, '-o', binFile]);
      _gccstderr = "";
      gcc.stderr.on('data', function(data) {
        return _gccstderr += data.toString();
      });
      gcc.on('exit', function(code, signal) {
        var prog, _stderr, _stdout;
        if (code !== 0) {
          onComplete(_gccstderr, "");
          return;
        }
        prog = spawn("./" + binFile, args);
        _stdout = "";
        prog.stdout.on('data', function(data) {
          console.log("program stdout data: " + data);
          return _stdout += data.toString();
        });
        _stderr = "";
        prog.stderr.on('data', function(data) {
          console.log("program stderr data: " + data);
          return _stderr += data.toString();
        });
        prog.on('close', function(code, signal) {
          if (code !== 0) {
            return onComplete(_stderr, "");
          } else {
            return onComplete(void 0, _stdout);
          }
        });
        return prog.stdin.write("hello world", function() {
          return prog.stdin.end();
        });
      });
      return gcc.stdin.end();
    });
  };

  exports.C = C = function(input) {
    var options;
    options = {};
    if (isFunction(input)) {
      return CParser(input, options);
    } else {
      options = input;
      return function(input) {
        return CParser(input, options);
      };
    }
  };

  Program = (function(_super) {

    __extends(Program, _super);

    function Program(src) {
      this.src = src;
      this.close = __bind(this.close, this);

      this.write = __bind(this.write, this);

      this.run = __bind(this.run, this);

      console.log(this.src);
      this._stdin = "";
      this._stdout = "";
      this.prog = {};
    }

    Program.prototype.run = function() {
      var args, x,
        _this = this;
      args = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          x = arguments[_i];
          _results.push(x);
        }
        return _results;
      }).apply(this, arguments);
      this.srcFile = 'output.c';
      this.binFile = 'output';
      console.log("writing file");
      fs.writeFile(this.srcFile, this.src, function(err) {
        var gcc;
        if (err) {
          throw err;
        }
        gcc = spawn('gcc', [_this.srcFile, '-o', _this.binFile]);
        gcc.stderr.on('data', function(data) {
          return _this.emit('gcc_err', data);
        });
        gcc.on('exit', function(code, signal) {
          _this.emit('gcc_exit', {
            code: code,
            signal: signal
          });
          if (code !== 0) {
            return;
          }
          console.log("program built");
          _this.prog = spawn("./" + _this.binFile, args.slice(0, args.length - 1));
          _this.prog.stdout.on('data', function(data) {
            return _this.emit('stdout', data);
          });
          _this.prog.stderr.on('data', function(data) {
            return _this.emit('stderr', data);
          });
          _this.prog.on('close', function(code, signal) {
            return _this.emit('close', {
              code: code,
              signal: signal
            });
          });
          return args[args.length - 1]();
        });
        return gcc.stdin.end();
      });
      return this;
    };

    Program.prototype.write = function(data, encoding, cb) {
      var _ref;
      if (((_ref = this.prog) != null ? _ref.stdout : void 0) == null) {
        throw new Error("cannot write to program, because it is not built");
      }
      this.prog.stdin.write(data, encoding, cb);
      return this;
    };

    Program.prototype.close = function(cb) {
      var _ref;
      if (((_ref = this.prog) != null ? _ref.stdin : void 0) == null) {
        throw new Error("cannot write to program, because it is not built");
      }
      if (cb != null) {
        this.prog.on('close', function(code, signal) {
          return cb({
            code: code,
            signal: signal
          });
        });
      }
      this.prog.stdin.end();
      return this;
    };

    return Program;

  })(Stream);

  exports.Program = Program;

}).call(this);
