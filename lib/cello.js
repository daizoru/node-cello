// Generated by CoffeeScript 1.4.0
(function() {
  var C, CParser, P, copy, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, pro, spawn, tmp, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  inspect = require('util').inspect;

  spawn = require('child_process').spawn;

  tmp = require('tmp');

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  CParser = function(func, options) {
    var ast, debug, functionCall, headers, ignore, include, includes, indent, indentationStr, mainCall, nodeToString, output, parseStatement, scope, scopes, src, _i, _len, _ref, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    debug = (_ref = options.debug) != null ? _ref : false;
    indentationStr = (_ref1 = options.indent) != null ? _ref1 : '\t';
    indent = function(n) {
      var _i;
      if (n == null) {
        n = 0;
      }
      tmp = "";
      if (indentationStr) {
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          tmp += indentationStr;
        }
      }
      return tmp;
    };
    ignore = (_ref2 = options.ignore) != null ? _ref2 : function() {};
    ignore = "var IGNORED = " + (ignore.toString()) + ";";
    if (debug) {
      console.log("ignore: " + ignore);
    }
    ignore = ['mutable', 'mutateNow'];
    src = func.toString();
    src = "var ROOT = " + src + ";";
    if (debug) {
      console.log("src: " + src);
    }
    ast = toAST(src);
    if (debug) {
      console.log("AST: " + (inspect(ast, false, 20, true)));
    }
    includes = [];
    scopes = [{}];
    scope = 0;
    nodeToString = function(n, ind) {
      var str, _ref3;
      if (ind == null) {
        ind = 0;
      }
      if (n[0] === 'binary') {
        return "(" + (nodeToString(n[2])) + " " + n[1] + " " + (nodeToString(n[3])) + ")";
      } else if (n[0] === 'string') {
        str = n[1];
        str.replace("\n", "\\n");
        return "\"" + str + "\"";
      } else if (_ref3 = n[0], __indexOf.call(ignore, _ref3) >= 0) {
        return nodeToString(n[1]);
      } else {
        return "" + n[1];
      }
    };
    mainCall = function(args, statements, ind) {
      var arg, body, res, statement, tmp2;
      if (ind == null) {
        ind = 0;
      }
      res = "";
      if (debug) {
        console.log("MAIN " + args + "  " + statements);
      }
      tmp = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          _results.push(nodeToString(arg));
        }
        return _results;
      })();
      args = tmp;
      body = "";
      tmp2 = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = statements.length; _i < _len; _i++) {
          statement = statements[_i];
          _results.push(body += parseStatement(statement, ind + 1));
        }
        return _results;
      })();
      return "int main(" + args + ") {\n" + body + (indent(ind + 1)) + "return 0;\n}\n";
    };
    functionCall = function(func, args, ind) {
      var arg, assignedValue, assignedVarName, res, symbol;
      if (ind == null) {
        ind = 0;
      }
      res = "";
      if (debug) {
        console.log("FUNCTION " + func[1] + " with args: " + (inspect(args, false, 20, true)));
      }
      symbol = func[1];
      if (symbol === 'int' || symbol === 'uint' || symbol === 'float' || symbol === 'ufloat' || symbol === 'double' || symbol === 'char') {
        if (args[0][0] === 'assign') {
          if (debug) {
            console.log("ASSIGN: " + (inspect(args, false, 20, true)));
          }
          assignedVarName = args[0][2][1];
          assignedValue = 0;
          if (args[0][3][0] === 'call') {
            assignedValue = functionCall(args[0][3][1], args[0][3][2]);
          } else {
            assignedValue = nodeToString(args[0][3]);
          }
          res += "" + (indent(ind)) + symbol + " " + assignedVarName + " = " + assignedValue + ";\n";
        }
      } else if (symbol === 'include') {
        res += "" + (indent(ind)) + "#include <" + args[0][1] + ">\n";
      } else if (__indexOf.call(ignore, symbol) >= 0) {
        if (debug) {
          console.log("function symbol " + symbol + " is in ignore list " + ignore);
        }
        res += nodeToString(args[0], ind);
      } else {
        tmp = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            _results.push(nodeToString(arg));
          }
          return _results;
        })();
        args = tmp;
        res += "" + (indent(ind)) + func[1] + "(" + args + ");\n";
      }
      return res;
    };
    output = (parseStatement = function(nodes, ind) {
      var args, n, node, res, statement, statements, _i, _j, _len, _len1, _ref3, _ref4;
      res = "";
      n = "" + nodes;
      if ('call,' === n.slice(0, 5)) {
        if (debug) {
          console.log("checking if " + nodes[1][1] + " is in " + ignore);
        }
        if (_ref3 = nodes[1][1], __indexOf.call(ignore, _ref3) >= 0) {
          if (debug) {
            console.log("IGNORE func: " + nodes[1] + ", args: " + (inspect(nodes[2], false, 20, true)));
          }
          _ref4 = nodes[2][0][3];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            statement = _ref4[_i];
            res += parseStatement(statement, ind);
          }
        } else {
          if (debug) {
            console.log("NOT ignoring");
          }
          res += functionCall(nodes[1], nodes[2], ind);
        }
      } else if ('assign,true,name,main,function,,' === n.slice(0, 32)) {
        args = nodes[3][2];
        statements = nodes[3][3];
        res += mainCall(args, statements, ind);
      } else if (isArray(nodes)) {
        for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
          node = nodes[_j];
          res += parseStatement(node, ind);
        }
      }
      return res;
    })(ast, 0);
    headers = "";
    for (_i = 0, _len = includes.length; _i < _len; _i++) {
      include = includes[_i];
      headers += "#include <" + include + ">\n";
    }
    output = headers + output;
    return output;
  };

  exports.compile = function(src, onComplete) {
    if (onComplete == null) {
      onComplete = function() {};
    }
    return fs.writeFile('output.c', src, function(err) {
      var gcc;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', ['output.c', '-o-']);
      gcc.on('exit', function(code, signal) {
        return onComplete(gcc.stdout);
      });
      return gcc.stdin.end();
    });
  };

  exports.run = function(src, onComplete) {
    var binFile, srcFile;
    if (onComplete == null) {
      onComplete = function() {};
    }
    srcFile = 'output.c';
    binFile = 'output';
    return fs.writeFile(srcFile, src, function(err) {
      var gcc;
      if (err) {
        throw err;
      }
      gcc = spawn('gcc', [srcFile, '-o', binFile]);
      gcc.on('exit', function(code, signal) {
        var prog, _stderr, _stdout;
        prog = spawn("./" + binFile, []);
        prog.stdin.end();
        _stdout = "";
        prog.stdout.on('data', function(data) {
          return _stdout += data.toString();
        });
        _stderr = "";
        prog.stderr.on('data', function(data) {
          return _stderr += data.toString();
        });
        return prog.on('exit', function(code, signal) {
          fs.unlink(binFile, function() {
            return fs.unlink(srcFile, function() {});
          });
          return onComplete(_stdout);
        });
      });
      return gcc.stdin.end();
    });
  };

  exports.C = C = function(input) {
    var options;
    options = {};
    if (isFunction(input)) {
      return CParser(input, options);
    } else {
      options = input;
      return function(input) {
        return CParser(input, options);
      };
    }
  };

}).call(this);
