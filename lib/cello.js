// Generated by CoffeeScript 1.4.0
(function() {
  var C, CParser, P, copy, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, pro, toAST;

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  fs = require('fs');

  inspect = require('util').inspect;

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  CParser = function(func, options) {
    var ast, debug, functionCall, headers, include, includes, indent, indentationStr, mainCall, nodeToString, output, parseStatement, scope, scopes, src, _i, _len, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    debug = (_ref = options.debug) != null ? _ref : false;
    indentationStr = (_ref1 = options.indent) != null ? _ref1 : '\t';
    indent = function(n) {
      var tmp, _i;
      if (n == null) {
        n = 0;
      }
      tmp = "";
      if (indentationStr) {
        for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
          tmp += indentationStr;
        }
      }
      return tmp;
    };
    src = func.toString();
    src = "var ROOT = " + src + ";";
    if (debug) {
      console.log("src: " + src);
    }
    ast = toAST(src);
    if (debug) {
      console.log("AST: " + (inspect(ast, false, 20, true)));
    }
    includes = [];
    scopes = [{}];
    scope = 0;
    output = "";
    nodeToString = function(n, ind) {
      var str;
      if (ind == null) {
        ind = 0;
      }
      if (debug) {
        console.log("VALUE " + (inspect(n, false, 20, true)));
      }
      if (n[0] === 'binary') {
        return "(" + (nodeToString(n[2])) + " " + n[1] + " " + (nodeToString(n[3])) + ")";
      } else if (n[0] === 'string') {
        str = n[1];
        str.replace("\n", "\\n");
        return "\"" + str + "\"";
      } else {
        return "" + n[1];
      }
    };
    mainCall = function(args, statements, ind) {
      var arg, body, statement, tmp, tmp2;
      if (ind == null) {
        ind = 0;
      }
      if (debug) {
        console.log("MAIN " + args + "  " + statements);
      }
      tmp = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          _results.push(nodeToString(arg));
        }
        return _results;
      })();
      args = tmp.join(', ');
      output += "" + (indent(ind)) + "main(" + args + ") {\n";
      tmp2 = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = statements.length; _i < _len; _i++) {
          statement = statements[_i];
          _results.push(parseStatement(statement, ind + 1));
        }
        return _results;
      })();
      body = tmp2.join(';\n');
      return output += "" + (indent(ind + 1)) + "return 0;\n}\n";
    };
    functionCall = function(func, args, ind) {
      var arg, assignedValue, assignedVarName, symbol, tmp;
      if (ind == null) {
        ind = 0;
      }
      if (debug) {
        console.log("FUNCTION " + func + " with args: " + args);
      }
      symbol = func[1];
      if (symbol === 'int' || symbol === 'uint' || symbol === 'float' || symbol === 'ufloat' || symbol === 'double' || symbol === 'char') {
        if (args[0][0] === 'assign') {
          if (debug) {
            console.log("ASSIGN: " + (inspect(args, false, 20, true)));
          }
          assignedVarName = args[0][2][1];
          assignedValue = nodeToString(args[0][3]);
          return output += "" + (indent(ind)) + symbol + " " + assignedVarName + " = " + assignedValue + ";\n";
        }
      } else if (symbol === 'include') {
        return output += "" + (indent(ind)) + "#include <" + args[0][1] + ">\n";
      } else {
        tmp = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            _results.push(nodeToString(arg));
          }
          return _results;
        })();
        args = tmp.join(', ');
        return output += "" + (indent(ind)) + func[1] + "(" + args + ");\n";
      }
    };
    (parseStatement = function(nodes, ind) {
      var args, n, node, statements, _i, _len, _results;
      n = "" + nodes;
      if ('call,' === n.slice(0, 5)) {
        return functionCall(nodes[1], nodes[2], ind);
      } else if ('assign,true,name,main,function,,' === n.slice(0, 32)) {
        args = nodes[3][2];
        statements = nodes[3][3];
        return mainCall(args, statements, ind);
      } else if (isArray(nodes)) {
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          _results.push(parseStatement(node, ind));
        }
        return _results;
      }
    })(ast, 0);
    headers = "";
    for (_i = 0, _len = includes.length; _i < _len; _i++) {
      include = includes[_i];
      headers += "#include <" + include + ">\n";
    }
    output = headers + output;
    return output;
  };

  exports.C = C = function(input) {
    var options;
    options = {};
    if (isFunction(input)) {
      return CParser(input, options);
    } else {
      options = input;
      return function(input) {
        return CParser(input, options);
      };
    }
  };

}).call(this);
